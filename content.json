{"meta":{"title":"怪客的Blog","subtitle":"分享一些黑科技","description":"","author":"guaik","url":"https://guaik.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-12T15:26:27.457Z","updated":"2020-04-12T11:12:33.055Z","comments":false,"path":"tags/index.html","permalink":"https://guaik.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-12T15:26:27.457Z","updated":"2020-04-12T11:13:05.148Z","comments":false,"path":"categories/index.html","permalink":"https://guaik.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"递归算法，lua的table与json互转","slug":"递归算法，lua的table与json互转","date":"2020-04-15T04:10:00.000Z","updated":"2020-04-15T04:49:56.164Z","comments":true,"path":"2020/04/15/递归算法，lua的table与json互转/","link":"","permalink":"https://guaik.github.io/2020/04/15/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%8Clua%E7%9A%84table%E4%B8%8Ejson%E4%BA%92%E8%BD%AC/","excerpt":"","text":"标题几乎是关键词组成，那么这篇文章会讲些什么？ 递归算法的使用 golang调用lua的方法 lua中table与json的相互转换 递归算法特性处理层级关系的结构，遍历数据非它莫属 如何设计递归 层级分类，统一函数参数与返回值 何时开始返回 应用小白能听懂的：什么是层级关系的结构呢？在windows系统中有个“我的电脑”，“我的电脑”中还有C,D,E,F盘，C盘中还有windows目录存放系统文件，D盘中还有我珍藏多年的【日本***空小姐】。所以最简单的理解就是一层套一层的关系。 中白能听懂的：二叉树遍历，父子节点关系。json中一层层的花括号{}。这些都是明显的层级关系。 所以本文中处理table与json的转换就使用递归算法。 golang如何调用lua的方法lua是什么首先它是一门脚本语言，但是它特别适合嵌入其他的语言中。那么为什么要嵌入其他语言呢？自己都是一个语言了在嵌入个lua不多余吗？ 我就拿C++举个栗子，C++的程序每次更新代码都是需要重新编译链接的，哪怕改动一点逻辑就要重新编译才行。某些情况下程序经常会修改一些业务逻辑，游戏中的智能状态机，在调试的时候每次修改都需要重新编译链接就太麻烦了，如果把状态机写个接口给lua去调用，修改脚本就可以调整状态机的逻辑，这太爽了。 安装lua的依赖包 1go get github.com/yuin/gopher-lua lua的运行时环境lua的运行状态（State）存放着运行时的一些关键数据：运行堆栈，上下文数据等（记不清了讲多了你也记不住），总之不同的状态是相互独立的，不同的状态间数据是不可见的，所以多线程安全。 创建lua状态 1env := lua.NewState() golang与lua的交互lua作为一门嵌入式的语言，有个很重要的特点就是能够在lua中能够调用被寄生语言的函数（寄生兽看过吧？），这样就完成了被寄宿的语言开放接口，然后通过lua编写脚本就能够方便的修改逻辑了。 在lua中注册新的函数 1234567/// 转换的逻辑是由golang编写的提供给lua调用的接口代码/// lua本身不支持table与json互转// table转json字符串env.SetGlobal(\"jsonMarshal\", env.NewFunction(luaJson.JsonMarshal))// json字符串转tableenv.SetGlobal(\"jsonUnMarshal\", env.NewFunction(luaJson.JsonUnMarshal)) 相关接口代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package jsonimport ( \"encoding/json\" \"github.com/golang/glog\" lua \"github.com/yuin/gopher-lua\")// 检查Table是否为Listfunc checkList(value lua.LValue) (b bool) &#123; if value.Type().String() == \"table\" &#123; b = true value.(*lua.LTable).ForEach(func(k, v lua.LValue) &#123; if k.Type().String() != \"number\" &#123; b = false return &#125; &#125;) &#125; return&#125;func marshal(data lua.LValue) interface&#123;&#125; &#123; switch data.Type() &#123; case lua.LTTable: if checkList(data) &#123; jdata := make([]interface&#123;&#125;, 0) data.(*lua.LTable).ForEach(func(key, value lua.LValue) &#123; jdata = append(jdata, marshal(value)) &#125;) return jdata &#125; else &#123; jdata := map[string]interface&#123;&#125;&#123;&#125; data.(*lua.LTable).ForEach(func(key, value lua.LValue) &#123; jdata[key.String()] = marshal(value) &#125;) return jdata &#125; case lua.LTNumber: return float64(data.(lua.LNumber)) case lua.LTString: return string(data.(lua.LString)) case lua.LTBool: return bool(data.(lua.LBool)) &#125; return nil&#125;func JsonMarshal(L *lua.LState) int &#123; data := L.ToTable(1) str, err := json.Marshal(marshal(data)) if err != nil &#123; glog.Error(err) &#125; L.Push(lua.LString(str)) return 1&#125;func unmarshal(L *lua.LState, data interface&#123;&#125;) lua.LValue &#123; switch data.(type) &#123; case map[string]interface&#123;&#125;: tb := L.NewTable() for k, v := range data.(map[string]interface&#123;&#125;) &#123; tb.RawSet(lua.LString(k), unmarshal(L, v)) &#125; return tb case []interface&#123;&#125;: tb := L.NewTable() for i, v := range data.([]interface&#123;&#125;) &#123; tb.Insert(i+1, unmarshal(L, v)) &#125; return tb case float64: return lua.LNumber(data.(float64)) case string: return lua.LString(data.(string)) case bool: return lua.LBool(data.(bool)) &#125; return lua.LNil&#125;func JsonUnMarshal(L *lua.LState) int &#123; str := L.ToString(1) jdata := map[string]interface&#123;&#125;&#123;&#125; err := json.Unmarshal([]byte(str), &amp;jdata) if err != nil &#123; glog.Error(err) &#125; L.Push(unmarshal(L, jdata)) return 1&#125; 在lua中调用golang提供的接口1234567891011121314function processor() data = &#123;&#125; data[\"hello\"]=\"world\" data[\"a\"] = &#123;&#125; data[\"a\"][\"b\"] = \"b\" data[\"a\"][\"c\"] = &#123;1,2,3,4,5,6&#125; res = jsonMarshal(data) res = jsonUnMarshal(res) for k,v in ipairs(res[\"a\"][\"c\"]) do print(k,v) end return trueend","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"递归","slug":"递归","permalink":"https://guaik.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"lua","slug":"lua","permalink":"https://guaik.github.io/tags/lua/"},{"name":"table","slug":"table","permalink":"https://guaik.github.io/tags/table/"},{"name":"json","slug":"json","permalink":"https://guaik.github.io/tags/json/"}]},{"title":"消息队列在前端的应用","slug":"消息队列在前端的应用","date":"2020-04-12T16:21:12.000Z","updated":"2020-04-15T04:50:19.316Z","comments":true,"path":"2020/04/13/消息队列在前端的应用/","link":"","permalink":"https://guaik.github.io/2020/04/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"队列与堆栈的区别队列由一个入口和一个出口组成，先进先出。堆栈只有一个口，后进先出。 生产消费者模型与队列队列是可以用来做缓冲区使用的，当短时间内出现大量数据的时候会造成软件或整个系统的不稳定，这时候我们就可以把数据先丢到队列中缓存起来，然后以合适的速度获取并处理数据保障系统的稳定。这就是生产消费模型，生产者负责生产数据而消费者负责处理数据。 消息队列在后端开发的应用 电商平台有一项业务：秒杀活动。在极短的时间内服务器将会收到大量商品的购买请求，如何降低业务服务器受到的冲击呢？我们会使用消息队列进行削峰处理。常用的后端消息队列有：Kafka、RabbitMQ、ActiveMQ、ZeroMQ。 消息队列通常都支持多个订阅者，利用这个特性可以实现一些服务的负载均衡功能。 📝正题：队列在前端的应用限速，让界面更流畅一些在聊天室应用中少则0人多则上万人，在收到大量即时通讯消息时如果不加处理全部拿去在界面做渲染那么轻则界面卡顿重则APP卡死。微信小程序给出的调用setData的最佳时间间隔为20ms，也就是如果把数据刷新的频率控制在20ms刷新一次是更合理的。所以消费者应该每隔20ms获取并处理一条数据保障界面的不卡。 减少没必要的内存浪费这样降低了消费的速度，会导致队列中的数据积压严重，大量消耗内存资源，一条消息在几分钟后被看到也是可能的，那如何处理呢？假设1秒钟收到了1000条聊天消息，那么这些消息需要全部显示吗？至少我的眼睛是来不及看完的，所以可以设定队列的最大长度，超出的消息全部丢弃（长度根据实际场景设定）。 保障重要的消息快速显示并且必须显示有个用户在直播间刷了个火箭，嗯，火箭被外星人劫走不见了，世界未解之谜出现。或者由于数据的积压火箭1分钟后终于出现了，主播都下播了。 为了避免上述问题，我们需要VIP队列，如果说普通聊天消息放入普通队列，那么现金礼物的就要放入VIP队列插队了，并且使命必达，有一条显示一条。这个实现也很容易，VIP队列的最大长度为∞大，不判断长度就行了，虽然也达不到1秒1000个火箭的量，但鱼丸就说不定了。由于VIP队列是独立于普通队列的，所以消息不会被排在普通队列的末尾，实现了插队的功能，通常这个队列的量不会特别大所以能够快速显示出来。 数据的融合，屏幕能显示N个列表项就刷新N条数据如果一个屏幕只能显示10个列表项，你每次有必要刷新10000条数据吗？还不够卡吗？所以当屏幕只能显示10个列表项的时候每次只刷新最新的100条数据，更多的请看聊天记录。这样就又多了一个列表用来存储可见数据了，这个列表只干一件事，融合普通队列和VIP队列的消息用于setData时刷新到屏幕上的数据。 🚀实战项目：gqueuehttps://github.com/GUAIK-ORG/gqueue","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://guaik.github.io/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://guaik.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://guaik.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"队列","slug":"队列","permalink":"https://guaik.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"聊天室","slug":"聊天室","permalink":"https://guaik.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"},{"name":"优化","slug":"优化","permalink":"https://guaik.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"加权随机算法","slug":"加权随机算法","date":"2020-04-12T14:02:06.000Z","updated":"2020-04-12T14:26:38.217Z","comments":true,"path":"2020/04/12/加权随机算法/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/","excerpt":"","text":"白话原理生活中最常见的一个例子：现在有4个红球和6个黑球，把这10个球放入到一个不透明的袋子中打乱，那么去袋子中拿到红球的概率是4/10，拿到黑球的概率是6/10，也可以说袋子分配给我红球的概率是4/10，分配给我黑球的概率是6/10。 实际应用 网关服务器通常都会通过负载均衡去分摊计算压力，有的服务器性能会好一些，有的会差一些，所以我们可以通过权重配比的形式将较大的计算压力给到性能较好的服务器。 当某台服务器突然出现故障时，微服务架构可以通过服务注册发现将故障的服务器移除，如果是网关服务器的话我们可以将负载均衡的权重置0。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 实例对象type Object struct &#123; Weight int // 权重 Object interface&#123;&#125; // 服务对象&#125;// 调度对象type Dispatch struct &#123; Sources []*Object // 所有服务对象 SLB []*Object // 负载均衡生成的对象 TotalWeight int // 总权重&#125;// 初始化func (dispatch *Dispatch) Init() (err error) &#123; dispatch.Sources = make([]*LiveObject, 0) dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 return&#125;// 重新生成负载均衡队列func (dispatch *Dispatch) reGenSLBArray() &#123; dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 for _, item := range dispatch.Sources &#123; dispatch.TotalWeight += item.Weight for i := 0; i &lt; item.Weight; i++ &#123; dispatch.SLB = append(dispatch.SLB, item) &#125; &#125; // 随机排列顺序 rand.Seed(time.Now().UnixNano()) rand.Shuffle(dispatch.TotalWeight, func(i, j int) &#123; dispatch.SLB[i], dispatch.SLB[j] = dispatch.SLB[j], dispatch.SLB[i] &#125;)&#125;// 添加服务对象func (dispatch *Dispatch) AddObject(object *Object) &#123; dispatch.Sources = append(dispatch.Sources, object) dispatch.reGenSLBArray()&#125;// 获取对象func (dispatch *Dispatch) GetObject() (object *Object) &#123; rand.Seed(time.Now().UnixNano()) return dispatch.SLB[rand.Intn(dispatch.TotalWeight)]&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"基于Redis的分布式锁","slug":"基于Redis的分布式锁","date":"2020-04-12T12:38:39.000Z","updated":"2020-04-12T15:07:03.488Z","comments":true,"path":"2020/04/12/基于Redis的分布式锁/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"为什么要使用分布式锁举个栗子，在设计直播间开播流程的时候会执行很多初始化的操作，也会在缓存中创建本次直播的记录数据，为了避免主播误操作同时执行开播流程多次，在开播成功后会设置开播状态，开播时判断状态为已开播则不处理，直播系统是多实例部署的，为了保护开播状态，需要做到同一时间只能由一台服务器处理开播流程，这时候就会用到分布式锁进行加锁保护。 线程锁与分布式锁锁的意义在于保护全局可见对象。在单进程中使用多线程时会通过线程锁去保护当前进程中的全局对象（某些情况可用原子操作）。分布式系统可理解为多进程系统，线程锁无法锁住其他进程中的执行流程，所以需要一个全局的锁来管控所有进程中的执行流程（如果相同名称的锁处于上锁状态则等待）。 Redis与SetNXRedis是单进程系统，它的SetNX是个原子操作，我们可以利用这两点来实现分布式锁。如果SetNX执行成功则意味着拿到了锁，相反执行失败则循环等待拿锁或超时退出。 设计注意事项1、为了避免单持有锁的进程奔溃而无法释放锁，所以必须能够为锁设定过期时间自动释放锁资源。 2、使用TTL检查锁是否成功的被设置过期时间，如果返回-1（未被设置）的话，使用Expire为其设定过期时间。 3、在释放锁的时候需要使用Watch命令，确保监测的值在事务执行时时未被改变，如果其他进程修改了锁，会触发事务异常，然后重新执行Watch。 分享一个我写的Redis封装类，仅实现了连接和锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package daoimport ( \"time\" \"github.com/go-redis/redis/v7\" uuid \"github.com/satori/go.uuid\")type Rds struct &#123; Client *redis.Client AcquireTimeout int32 LockTimeout int32&#125;func NewRds(host, passwd string, db int) (rds *Rds, err error) &#123; rdsOpt := &amp;redis.Options&#123; Addr: host, Password: passwd, DB: db, &#125; client := redis.NewClient(rdsOpt) _, err = client.Ping().Result() if err != nil &#123; return &#125; rds = &amp;Rds&#123;Client: client, AcquireTimeout: 10, LockTimeout: 10&#125; return&#125;func (r *Rds) AcquireLockWithTimeout(key string) (identifier string, b bool) &#123; identifier = uuid.NewV4().String() lockname := \"lock:\" + key end := time.Now().Add(time.Second * time.Duration(r.AcquireTimeout)) for time.Now().Before(end) &#123; if r.Client.SetNX(lockname, identifier, time.Second*time.Duration(r.LockTimeout)).Val() &#123; // 如果key不存在，并成功设置了key b = true return &#125; else if r.Client.TTL(lockname).Val() == -1 &#123; // 如果key存在，但是没有剩余时间 r.Client.Expire(lockname, time.Second*time.Duration(r.LockTimeout)) &#125; time.Sleep(time.Microsecond) &#125; return&#125;func (r *Rds) ReleaseLock(key, identifier string) (b bool) &#123; lockname := \"lock:\" + key txf := func(tx *redis.Tx) error &#123; v, err := tx.Get(lockname).Result() if err != nil &#123; return err &#125; _, err = tx.Pipelined(func(pipe redis.Pipeliner) error &#123; if v == identifier &#123; pipe.Del(lockname) b = true &#125; return nil &#125;) return err &#125; for &#123; err := r.Client.Watch(txf, lockname) if err == nil &#123; break &#125; else if err == redis.TxFailedErr &#123; glog.Error(err) &#125; &#125; return&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}],"categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"递归","slug":"递归","permalink":"https://guaik.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"lua","slug":"lua","permalink":"https://guaik.github.io/tags/lua/"},{"name":"table","slug":"table","permalink":"https://guaik.github.io/tags/table/"},{"name":"json","slug":"json","permalink":"https://guaik.github.io/tags/json/"},{"name":"typescript","slug":"typescript","permalink":"https://guaik.github.io/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://guaik.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://guaik.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"队列","slug":"队列","permalink":"https://guaik.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"聊天室","slug":"聊天室","permalink":"https://guaik.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"},{"name":"优化","slug":"优化","permalink":"https://guaik.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}