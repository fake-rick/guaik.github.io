{"meta":{"title":"怪客的博客","subtitle":"","description":"","author":"guaik","url":"https://guaik.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-12T11:12:33.068Z","updated":"2020-04-12T11:12:33.055Z","comments":false,"path":"tags/index.html","permalink":"https://guaik.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-12T11:13:05.159Z","updated":"2020-04-12T11:13:05.148Z","comments":false,"path":"categories/index.html","permalink":"https://guaik.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang基于Redis的分布式锁","slug":"Golang基于Redis的分布式锁","date":"2020-04-12T12:38:39.000Z","updated":"2020-04-12T13:01:59.168Z","comments":true,"path":"2020/04/12/Golang基于Redis的分布式锁/","link":"","permalink":"https://guaik.github.io/2020/04/12/Golang%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"分布式锁1、为了避免单持有锁的进程奔溃而无法释放锁，所以必须能够为锁设定过期时间自动释放锁资源 2、使用TTL检查锁是否成功的被设置过期时间，如果返回-1（未被设置）的话，使用Expire为其设定过期时间 3、在释放锁的时候需要使用Watch命令，确保监测的值在事务执行时时未被改变，如果其他进程修改了锁，会触发事务异常，然后重新执行Watch。 分享一个我写的Redis封装类，仅实现了连接和锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package daoimport ( \"time\" \"github.com/go-redis/redis/v7\" uuid \"github.com/satori/go.uuid\")type Rds struct &#123; Client *redis.Client AcquireTimeout int32 LockTimeout int32&#125;func NewRds(host, passwd string, db int) (rds *Rds, err error) &#123; rdsOpt := &amp;redis.Options&#123; Addr: host, Password: passwd, DB: db, &#125; client := redis.NewClient(rdsOpt) _, err = client.Ping().Result() if err != nil &#123; return &#125; rds = &amp;Rds&#123;Client: client, AcquireTimeout: 10, LockTimeout: 10&#125; return&#125;func (r *Rds) AcquireLockWithTimeout(key string) (identifier string, b bool) &#123; identifier = uuid.NewV4().String() lockname := \"lock:\" + key end := time.Now().Add(time.Second * time.Duration(r.AcquireTimeout)) for time.Now().Before(end) &#123; if r.Client.SetNX(lockname, identifier, time.Second*time.Duration(r.LockTimeout)).Val() &#123; // 如果key不存在，并成功设置了key b = true return &#125; else if r.Client.TTL(lockname).Val() == -1 &#123; // 如果key存在，但是没有剩余时间 r.Client.Expire(lockname, time.Second*time.Duration(r.LockTimeout)) &#125; time.Sleep(time.Microsecond) &#125; return&#125;func (r *Rds) ReleaseLock(key, identifier string) (b bool) &#123; lockname := \"lock:\" + key txf := func(tx *redis.Tx) error &#123; v, err := tx.Get(lockname).Result() if err != nil &#123; return err &#125; _, err = tx.Pipelined(func(pipe redis.Pipeliner) error &#123; if v == identifier &#123; pipe.Del(lockname) b = true &#125; return nil &#125;) return err &#125; for &#123; err := r.Client.Watch(txf, lockname) if err == nil &#123; break &#125; else if err == redis.TxFailedErr &#123; glog.Error(err) &#125; &#125; return&#125;","categories":[{"name":"分布式","slug":"分布式","permalink":"https://guaik.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}],"categories":[{"name":"分布式","slug":"分布式","permalink":"https://guaik.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}