{"meta":{"title":"怪客的Blog","subtitle":"分享一些黑科技","description":"","author":"guaik","url":"https://guaik.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-12T15:26:27.457Z","updated":"2020-04-12T11:12:33.055Z","comments":false,"path":"tags/index.html","permalink":"https://guaik.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-12T15:26:27.457Z","updated":"2020-04-12T11:13:05.148Z","comments":false,"path":"categories/index.html","permalink":"https://guaik.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"搞定网络爬虫登陆验证","slug":"搞定网络爬虫登陆验证","date":"2020-06-04T02:04:40.000Z","updated":"2020-06-04T04:09:20.432Z","comments":true,"path":"2020/06/04/搞定网络爬虫登陆验证/","link":"","permalink":"https://guaik.github.io/2020/06/04/%E6%90%9E%E5%AE%9A%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81/","excerpt":"","text":"登陆验证是什么？https://www.wjx.cn/wjx/viewfile.aspx?path=https%3a%2f%2fpubuserqiniu.paperol.cn%2f80373144_1_q1_1591205817ZF4mBh.png%3fattname%3d1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png&amp;activity=80373144 先点上边链接，发现打开的不是一张图片，而是一个登陆页面。 login 分析url分析上边url是一个图片连接，但是实际的图片url是作为参数(path)传给服务器的 1https%3a%2f%2fpubuserqiniu.paperol.cn%2f80373144_1_q1_1591205817ZF4mBh.png%3fattname%3d1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png 使用url解码看下图片地址 1https://pubuserqiniu.paperol.cn/80373144_1_q1_1591205817ZF4mBh.png?attname=1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png 可以知道图片存储用的是七牛云的对象存储服务。 登陆分析 Chrome浏览器，打开“开发者工具”，点击“Network”，如果“Network”中存在内容，就先清空一下。 输入账号密码（可能需要输入验证码）登陆，查看“Network”中的数据： 当输入完账号密码后，图片已经被下载了 登陆 通过上图可以知道获取一个图片是经过了3个步骤的，前两步骤的返回状态码都是302（重定向），第三步才是真正的请求。 点击第一个URL 分析1 因为是302状态，所以检查返回数据的头部信息，能够发现两个关键参数：1、重定向地址（Location）。2、本地请求会在本地设置的Cookie。 所有我们在开发脚本的时候也会使用到Cookie的功能。 点击第二个URL(为第一个URL重定向的目标地址) 分析2 这里有个重要信息，重定向的地址中带有token参数 第三步，最后一步！ 分析3 继续分析返回数据，发现Content-Type是image/png，这时候就可以确认返回的数据是图片格式了。 爬虫设计开发语言：Python3.X 需求1：需要登陆验证，并且要处理登陆验证码实现：直接使用浏览器登陆后使用浏览器生成的Cookie，用到的库： 1pip3 install browser_cookie3 需求2：在请求数据的时候，前两次重定向应答的headers中都需要设置Cookie实现：使用urllib.request.HTTPCookieProcessor来管理Cookie DEMO⚠️注意事项： 1、测试发现需要登陆管理后台，下载最新的分析报告(excel)，从里边拿到图片的url才能使用当前浏览器的Cookie进行操作。 2、第一次GET请求后发现headers中没有Location字段，但是在返回内容中找到了重定向用到的的url，所以用xpath提取出来使用。 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import browser_cookie3import urllib.requestfrom lxml import etreedef download(): url = \"https://www.wjx.cn/wjx/viewfile.aspx?path=https%3a%2f%2fpubuserqiniu.paperol.cn%2f80373144_1_q1_1591205817ZF4mBh.png%3fattname%3d1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png&amp;activity=80373144\" filename = \"./demo.png\" try: # 获取 cj = browser_cookie3.Firefox().load() opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj)) request = urllib.request.Request(url) # 第一次请求 response = opener.open(request) data = response.read() html = etree.HTML(data) url = 'https://www.wjx.cn' + html.xpath('//a/@href')[0] request = urllib.request.Request(url, method=\"GET\") # 第二次请求 response = opener.open(request) if (response.getcode() == 200): with open(filename, \"wb\") as f: f.write(response.read()) # 将内容写入图片 except Exception as e: print(filename)if __name__ == \"__main__\": download()","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://guaik.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"验证","slug":"验证","permalink":"https://guaik.github.io/tags/%E9%AA%8C%E8%AF%81/"}]},{"title":"Flutter使用SharedPreferences：单例+同步","slug":"Flutter使用SharedPreferences：单例+同步","date":"2020-05-23T13:38:32.000Z","updated":"2020-05-25T02:23:20.955Z","comments":true,"path":"2020/05/23/Flutter使用SharedPreferences：单例+同步/","link":"","permalink":"https://guaik.github.io/2020/05/23/Flutter%E4%BD%BF%E7%94%A8SharedPreferences%EF%BC%9A%E5%8D%95%E4%BE%8B+%E5%90%8C%E6%AD%A5/","excerpt":"","text":"Flutter如何本地存储K/V数据呢？SharedPreferences是个不错的选择，当然几乎所有嵌入式系统都支持SQLite，你乐意就好。 安装SharedPreferences 在pubspec.yaml中添加依赖项 12dependencies: shared_preferences: ^0.5.7+3 安装依赖项flutter pub get SharedPreferences如何使用？太简单了，直接上代码123456789101112// 存储token字符串void SetToken(token) async &#123; this.prefs = await SharedPreferences.getInstance(); this.prefs.setString(\"token\", token);&#125;// 获取token字符串Future&lt;String&gt; GetToken() async &#123; this.prefs = await SharedPreferences.getInstance(); String token = this.prefs.getString(\"token\"); return token == null ? \"\" : token;&#125; 上面示例用了setString和getString来处理字符串，还支持对int,bool,double,List&lt;String&gt;类型的处理。 示例分析 await SharedPreferences.getInstance()从这行代码可以了解到的信息是：1、SharedPreferences采用了异步调用。2、静态方法getInstance()可以确定它是个单例模式。 如果所有使用到存储的函数都采用异步调用可能会产生一些问题，在Flutter的页面代码中Widget build(BuildContext context)需要返回一个Widget的对象，有时候我们需要从本地存储中读取状态值来确定返回什么页面。如果是异步调用的话可能会返回一个null值而导致编译报错，因为异步调用不会等待函数执行完就继续执行下面的流程了，这时候很有可能就执行完函数并且什么都没返回。 123456789101112131415161718class _StartupPageState extends State&lt;StartupPage&gt; &#123; @override Widget build(BuildContext context) &#123; Widget page; SharedPreferences.getInstance().then((prefs) &#123; var isFirst = prefs.getBool(\"isFirst\"); if (isFirst == null || false) &#123; // 如果是第一次登陆，则显示启动页 page = BootstrapPage(); &#125; else &#123; // 否则执行跳转到登陆页 page = LoginPage(); &#125; &#125;); // 这里可能返回null值 return page; &#125;&#125; SharedPreferences使用单例模式再封装 在main函数中调用Init生成实力并存储SharedPreferences对，这样就不用每次异步获取了。 123456789101112131415class Storage &#123; Storage._(); SharedPreferences prefs; static Storage _instance; static Storage getInstance() &#123; if(_instance == null) &#123; _instance = Storage._(); &#125; return _instance; &#125; Init() async &#123; this.prefs = await SharedPreferences.getInstance(); &#125;&#125; 初始化123456789void startup() async &#123; await Storage.getInstance().Init(); runApp(new MyApp());&#125;void main() &#123; WidgetsFlutterBinding.ensureInitialized(); startup();&#125; 使用Storage单例 感谢猫哥提醒：在SharedPreferences中，所有的写入操作都是异步函数，包含（set, clear），所有的get都是同步函数。 1234567891011121314151617// 存储token字符串// setString为异步函数，如果是同步逻辑需要使用await。void SetToken(token) async&#123; await torage.getInstance().prefs.setString(\"token\", token);&#125;// 获取token字符串String GetToken() &#123; String token = Storage.getInstance().prefs.getString(\"token\"); return token == null ? \"\" : token;&#125;// 获取是否第一次运行bool isFirst() &#123; var state = Storage.getInstance().prefs.getBool(\"isFirst\"); return state == null ? false : true;&#125;","categories":[{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/tags/flutter/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://guaik.github.io/tags/SharedPreferences/"},{"name":"单例模式","slug":"单例模式","permalink":"https://guaik.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"同步","slug":"同步","permalink":"https://guaik.github.io/tags/%E5%90%8C%E6%AD%A5/"}]},{"title":"递归算法，lua的table与json互转","slug":"递归算法，lua的table与json互转","date":"2020-04-15T04:10:00.000Z","updated":"2020-05-23T13:43:21.418Z","comments":true,"path":"2020/04/15/递归算法，lua的table与json互转/","link":"","permalink":"https://guaik.github.io/2020/04/15/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%8Clua%E7%9A%84table%E4%B8%8Ejson%E4%BA%92%E8%BD%AC/","excerpt":"","text":"标题几乎是关键词组成，那么这篇文章会讲些什么？ 递归算法的使用 golang调用lua的方法 lua中table与json的相互转换 递归算法特性处理层级关系的结构，遍历数据非它莫属 如何设计递归 层级分类，统一函数参数与返回值 何时开始返回 应用小白能听懂的：什么是层级关系的结构呢？在windows系统中有个“我的电脑”，“我的电脑”中还有C,D,E,F盘，C盘中还有windows目录存放系统文件，D盘中还有我珍藏多年的【日本***空小姐】。所以最简单的理解就是一层套一层的关系。 中白能听懂的：二叉树遍历，父子节点关系。json中一层层的花括号{}。这些都是明显的层级关系。 所以本文中处理table与json的转换就使用递归算法。 golang如何调用lua的方法lua是什么首先它是一门脚本语言，但是它特别适合嵌入其他的语言中。那么为什么要嵌入其他语言呢？自己都是一个语言了在嵌入个lua不多余吗？ 我就拿C++举个栗子，C++的程序每次更新代码都是需要重新编译链接的，哪怕改动一点逻辑就要重新编译才行。某些情况下程序经常会修改一些业务逻辑，游戏中的智能状态机，在调试的时候每次修改都需要重新编译链接就太麻烦了，如果把状态机写个接口给lua去调用，修改脚本就可以调整状态机的逻辑，这太爽了。 安装lua的依赖包 1go get github.com/yuin/gopher-lua lua的运行时环境lua的运行状态（State）存放着运行时的一些关键数据：运行堆栈，上下文数据等（记不清了讲多了你也记不住），总之不同的状态是相互独立的，不同的状态间数据是不可见的，所以多线程安全。 创建lua状态 1env := lua.NewState() golang与lua的交互lua作为一门嵌入式的语言，有个很重要的特点就是能够在lua中能够调用被寄生语言的函数（寄生兽看过吧？），这样就完成了被寄宿的语言开放接口，然后通过lua编写脚本就能够方便的修改逻辑了。 在lua中注册新的函数 1234567/// 转换的逻辑是由golang编写的提供给lua调用的接口代码/// lua本身不支持table与json互转// table转json字符串env.SetGlobal(\"jsonMarshal\", env.NewFunction(luaJson.JsonMarshal))// json字符串转tableenv.SetGlobal(\"jsonUnMarshal\", env.NewFunction(luaJson.JsonUnMarshal)) 相关接口代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package jsonimport ( \"encoding/json\" \"github.com/golang/glog\" lua \"github.com/yuin/gopher-lua\")// 检查Table是否为Listfunc checkList(value lua.LValue) (b bool) &#123; if value.Type().String() == \"table\" &#123; b = true value.(*lua.LTable).ForEach(func(k, v lua.LValue) &#123; if k.Type().String() != \"number\" &#123; b = false return &#125; &#125;) &#125; return&#125;func marshal(data lua.LValue) interface&#123;&#125; &#123; switch data.Type() &#123; case lua.LTTable: if checkList(data) &#123; jdata := make([]interface&#123;&#125;, 0) data.(*lua.LTable).ForEach(func(key, value lua.LValue) &#123; jdata = append(jdata, marshal(value)) &#125;) return jdata &#125; else &#123; jdata := map[string]interface&#123;&#125;&#123;&#125; data.(*lua.LTable).ForEach(func(key, value lua.LValue) &#123; jdata[key.String()] = marshal(value) &#125;) return jdata &#125; case lua.LTNumber: return float64(data.(lua.LNumber)) case lua.LTString: return string(data.(lua.LString)) case lua.LTBool: return bool(data.(lua.LBool)) &#125; return nil&#125;func JsonMarshal(L *lua.LState) int &#123; data := L.ToTable(1) str, err := json.Marshal(marshal(data)) if err != nil &#123; glog.Error(err) &#125; L.Push(lua.LString(str)) return 1&#125;func unmarshal(L *lua.LState, data interface&#123;&#125;) lua.LValue &#123; switch data.(type) &#123; case map[string]interface&#123;&#125;: tb := L.NewTable() for k, v := range data.(map[string]interface&#123;&#125;) &#123; tb.RawSet(lua.LString(k), unmarshal(L, v)) &#125; return tb case []interface&#123;&#125;: tb := L.NewTable() for i, v := range data.([]interface&#123;&#125;) &#123; tb.Insert(i+1, unmarshal(L, v)) &#125; return tb case float64: return lua.LNumber(data.(float64)) case string: return lua.LString(data.(string)) case bool: return lua.LBool(data.(bool)) &#125; return lua.LNil&#125;func JsonUnMarshal(L *lua.LState) int &#123; str := L.ToString(1) jdata := map[string]interface&#123;&#125;&#123;&#125; err := json.Unmarshal([]byte(str), &amp;jdata) if err != nil &#123; glog.Error(err) &#125; L.Push(unmarshal(L, jdata)) return 1&#125; 在lua中调用golang提供的接口1234567891011121314function processor() data = &#123;&#125; data[\"hello\"]=\"world\" data[\"a\"] = &#123;&#125; data[\"a\"][\"b\"] = \"b\" data[\"a\"][\"c\"] = &#123;1,2,3,4,5,6&#125; res = jsonMarshal(data) res = jsonUnMarshal(res) for k,v in ipairs(res[\"a\"][\"c\"]) do print(k,v) end return trueend","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"递归","slug":"递归","permalink":"https://guaik.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"lua","slug":"lua","permalink":"https://guaik.github.io/tags/lua/"},{"name":"table","slug":"table","permalink":"https://guaik.github.io/tags/table/"},{"name":"json","slug":"json","permalink":"https://guaik.github.io/tags/json/"}]},{"title":"消息队列在前端的应用","slug":"消息队列在前端的应用","date":"2020-04-12T16:21:12.000Z","updated":"2020-04-15T04:52:05.609Z","comments":true,"path":"2020/04/13/消息队列在前端的应用/","link":"","permalink":"https://guaik.github.io/2020/04/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"队列与堆栈的区别队列由一个入口和一个出口组成，先进先出。堆栈只有一个口，后进先出。 生产消费者模型与队列队列是可以用来做缓冲区使用的，当短时间内出现大量数据的时候会造成软件或整个系统的不稳定，这时候我们就可以把数据先丢到队列中缓存起来，然后以合适的速度获取并处理数据保障系统的稳定。这就是生产消费模型，生产者负责生产数据而消费者负责处理数据。 消息队列在后端开发的应用 电商平台有一项业务：秒杀活动。在极短的时间内服务器将会收到大量商品的购买请求，如何降低业务服务器受到的冲击呢？我们会使用消息队列进行削峰处理。常用的后端消息队列有：Kafka、RabbitMQ、ActiveMQ、ZeroMQ。 消息队列通常都支持多个订阅者，利用这个特性可以实现一些服务的负载均衡功能。 📝正题：队列在前端的应用限速，让界面更流畅一些在聊天室应用中少则0人多则上万人，在收到大量即时通讯消息时如果不加处理全部拿去在界面做渲染那么轻则界面卡顿重则APP卡死。微信小程序给出的调用setData的最佳时间间隔为20ms，也就是如果把数据刷新的频率控制在20ms刷新一次是更合理的。所以消费者应该每隔20ms获取并处理一条数据保障界面的不卡。 减少没必要的内存浪费这样降低了消费的速度，会导致队列中的数据积压严重，大量消耗内存资源，一条消息在几分钟后被看到也是可能的，那如何处理呢？假设1秒钟收到了1000条聊天消息，那么这些消息需要全部显示吗？至少我的眼睛是来不及看完的，所以可以设定队列的最大长度，超出的消息全部丢弃（长度根据实际场景设定）。 保障重要的消息快速显示并且必须显示有个用户在直播间刷了个火箭，嗯，火箭被外星人劫走不见了，世界未解之谜出现。或者由于数据的积压火箭1分钟后终于出现了，主播都下播了。 为了避免上述问题，我们需要VIP队列，如果说普通聊天消息放入普通队列，那么现金礼物的就要放入VIP队列插队了，并且使命必达，有一条显示一条。这个实现也很容易，VIP队列的最大长度为∞大，不判断长度就行了，虽然也达不到1秒1000个火箭的量，但鱼丸就说不定了。由于VIP队列是独立于普通队列的，所以消息不会被排在普通队列的末尾，实现了插队的功能，通常这个队列的量不会特别大所以能够快速显示出来。 数据的融合，屏幕能显示N个列表项就刷新N条数据如果一个屏幕只能显示10个列表项，你每次有必要刷新10000条数据吗？还不够卡吗？所以当屏幕只能显示10个列表项的时候每次只刷新最新的100条数据，更多的请看聊天记录。这样就又多了一个列表用来存储可见数据了，这个列表只干一件事，融合普通队列和VIP队列的消息用于setData时刷新到屏幕上的数据。 🚀实战项目：gqueuehttps://github.com/GUAIK-ORG/gqueue","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://guaik.github.io/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://guaik.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://guaik.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"队列","slug":"队列","permalink":"https://guaik.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"加权随机算法","slug":"加权随机算法","date":"2020-04-12T14:02:06.000Z","updated":"2020-04-12T14:26:38.217Z","comments":true,"path":"2020/04/12/加权随机算法/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/","excerpt":"","text":"白话原理生活中最常见的一个例子：现在有4个红球和6个黑球，把这10个球放入到一个不透明的袋子中打乱，那么去袋子中拿到红球的概率是4/10，拿到黑球的概率是6/10，也可以说袋子分配给我红球的概率是4/10，分配给我黑球的概率是6/10。 实际应用 网关服务器通常都会通过负载均衡去分摊计算压力，有的服务器性能会好一些，有的会差一些，所以我们可以通过权重配比的形式将较大的计算压力给到性能较好的服务器。 当某台服务器突然出现故障时，微服务架构可以通过服务注册发现将故障的服务器移除，如果是网关服务器的话我们可以将负载均衡的权重置0。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 实例对象type Object struct &#123; Weight int // 权重 Object interface&#123;&#125; // 服务对象&#125;// 调度对象type Dispatch struct &#123; Sources []*Object // 所有服务对象 SLB []*Object // 负载均衡生成的对象 TotalWeight int // 总权重&#125;// 初始化func (dispatch *Dispatch) Init() (err error) &#123; dispatch.Sources = make([]*LiveObject, 0) dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 return&#125;// 重新生成负载均衡队列func (dispatch *Dispatch) reGenSLBArray() &#123; dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 for _, item := range dispatch.Sources &#123; dispatch.TotalWeight += item.Weight for i := 0; i &lt; item.Weight; i++ &#123; dispatch.SLB = append(dispatch.SLB, item) &#125; &#125; // 随机排列顺序 rand.Seed(time.Now().UnixNano()) rand.Shuffle(dispatch.TotalWeight, func(i, j int) &#123; dispatch.SLB[i], dispatch.SLB[j] = dispatch.SLB[j], dispatch.SLB[i] &#125;)&#125;// 添加服务对象func (dispatch *Dispatch) AddObject(object *Object) &#123; dispatch.Sources = append(dispatch.Sources, object) dispatch.reGenSLBArray()&#125;// 获取对象func (dispatch *Dispatch) GetObject() (object *Object) &#123; rand.Seed(time.Now().UnixNano()) return dispatch.SLB[rand.Intn(dispatch.TotalWeight)]&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"基于Redis的分布式锁","slug":"基于Redis的分布式锁","date":"2020-04-12T12:38:39.000Z","updated":"2020-04-12T15:07:03.488Z","comments":true,"path":"2020/04/12/基于Redis的分布式锁/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"为什么要使用分布式锁举个栗子，在设计直播间开播流程的时候会执行很多初始化的操作，也会在缓存中创建本次直播的记录数据，为了避免主播误操作同时执行开播流程多次，在开播成功后会设置开播状态，开播时判断状态为已开播则不处理，直播系统是多实例部署的，为了保护开播状态，需要做到同一时间只能由一台服务器处理开播流程，这时候就会用到分布式锁进行加锁保护。 线程锁与分布式锁锁的意义在于保护全局可见对象。在单进程中使用多线程时会通过线程锁去保护当前进程中的全局对象（某些情况可用原子操作）。分布式系统可理解为多进程系统，线程锁无法锁住其他进程中的执行流程，所以需要一个全局的锁来管控所有进程中的执行流程（如果相同名称的锁处于上锁状态则等待）。 Redis与SetNXRedis是单进程系统，它的SetNX是个原子操作，我们可以利用这两点来实现分布式锁。如果SetNX执行成功则意味着拿到了锁，相反执行失败则循环等待拿锁或超时退出。 设计注意事项1、为了避免单持有锁的进程奔溃而无法释放锁，所以必须能够为锁设定过期时间自动释放锁资源。 2、使用TTL检查锁是否成功的被设置过期时间，如果返回-1（未被设置）的话，使用Expire为其设定过期时间。 3、在释放锁的时候需要使用Watch命令，确保监测的值在事务执行时时未被改变，如果其他进程修改了锁，会触发事务异常，然后重新执行Watch。 分享一个我写的Redis封装类，仅实现了连接和锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package daoimport ( \"time\" \"github.com/go-redis/redis/v7\" uuid \"github.com/satori/go.uuid\")type Rds struct &#123; Client *redis.Client AcquireTimeout int32 LockTimeout int32&#125;func NewRds(host, passwd string, db int) (rds *Rds, err error) &#123; rdsOpt := &amp;redis.Options&#123; Addr: host, Password: passwd, DB: db, &#125; client := redis.NewClient(rdsOpt) _, err = client.Ping().Result() if err != nil &#123; return &#125; rds = &amp;Rds&#123;Client: client, AcquireTimeout: 10, LockTimeout: 10&#125; return&#125;func (r *Rds) AcquireLockWithTimeout(key string) (identifier string, b bool) &#123; identifier = uuid.NewV4().String() lockname := \"lock:\" + key end := time.Now().Add(time.Second * time.Duration(r.AcquireTimeout)) for time.Now().Before(end) &#123; if r.Client.SetNX(lockname, identifier, time.Second*time.Duration(r.LockTimeout)).Val() &#123; // 如果key不存在，并成功设置了key b = true return &#125; else if r.Client.TTL(lockname).Val() == -1 &#123; // 如果key存在，但是没有剩余时间 r.Client.Expire(lockname, time.Second*time.Duration(r.LockTimeout)) &#125; time.Sleep(time.Microsecond) &#125; return&#125;func (r *Rds) ReleaseLock(key, identifier string) (b bool) &#123; lockname := \"lock:\" + key txf := func(tx *redis.Tx) error &#123; v, err := tx.Get(lockname).Result() if err != nil &#123; return err &#125; _, err = tx.Pipelined(func(pipe redis.Pipeliner) error &#123; if v == identifier &#123; pipe.Del(lockname) b = true &#125; return nil &#125;) return err &#125; for &#123; err := r.Client.Watch(txf, lockname) if err == nil &#123; break &#125; else if err == redis.TxFailedErr &#123; glog.Error(err) &#125; &#125; return&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}],"categories":[{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/categories/flutter/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://guaik.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"验证","slug":"验证","permalink":"https://guaik.github.io/tags/%E9%AA%8C%E8%AF%81/"},{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/tags/flutter/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://guaik.github.io/tags/SharedPreferences/"},{"name":"单例模式","slug":"单例模式","permalink":"https://guaik.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"同步","slug":"同步","permalink":"https://guaik.github.io/tags/%E5%90%8C%E6%AD%A5/"},{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"递归","slug":"递归","permalink":"https://guaik.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"lua","slug":"lua","permalink":"https://guaik.github.io/tags/lua/"},{"name":"table","slug":"table","permalink":"https://guaik.github.io/tags/table/"},{"name":"json","slug":"json","permalink":"https://guaik.github.io/tags/json/"},{"name":"typescript","slug":"typescript","permalink":"https://guaik.github.io/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://guaik.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://guaik.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"队列","slug":"队列","permalink":"https://guaik.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}