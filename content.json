{"meta":{"title":"Rick's blog","subtitle":"分享一些黑科技","description":"","author":"Rick","url":"https://guaik.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-12T15:26:27.457Z","updated":"2020-04-12T11:12:33.055Z","comments":false,"path":"tags/index.html","permalink":"https://guaik.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-12T15:26:27.457Z","updated":"2020-04-12T11:13:05.148Z","comments":false,"path":"categories/index.html","permalink":"https://guaik.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"朴素贝叶斯算法识别垃圾短信","slug":"朴素贝叶斯算法识别垃圾短信","date":"2021-01-29T10:07:43.000Z","updated":"2021-01-29T10:27:54.347Z","comments":true,"path":"2021/01/29/朴素贝叶斯算法识别垃圾短信/","link":"","permalink":"https://guaik.github.io/2021/01/29/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/","excerpt":"","text":"训练集下载(sms_data.txt)点击下载 Cargo.toml1234567891011121314151617[package]name &#x3D; &quot;bayes&quot;version &#x3D; &quot;0.1.0&quot;authors &#x3D; [&quot;Rick.Gu &lt;rick@guaik.org&gt;&quot;]edition &#x3D; &quot;2018&quot;# See more keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html[dependencies]ndarray &#x3D; &quot;0.14.0&quot;jieba-rs &#x3D; &quot;0.6&quot;serde &#x3D; &#123; version &#x3D; &quot;1.0&quot;, features &#x3D; [&quot;derive&quot;] &#125;serde_json &#x3D; &quot;1.0&quot;# [lib]# name &#x3D; &quot;bayes&quot;# crate-type &#x3D; [&quot;staticlib&quot;] bayes.rs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276//! 朴素贝叶斯算法use jieba_rs::Jieba;use ndarray::&#123;self, arr1, Array1, Array2&#125;;use std::collections::HashSet;use std::fs;use std::io::Write;use serde::&#123;Deserialize, Serialize&#125;;use serde_json;use crate::utils;#[derive(Deserialize, Serialize)]pub struct BayesModel &#123; init_val: f64, // 所有词的初始化出现数 denom: f64, // 默认分母 p0: Vec&lt;f64&gt;, // 正确概率数组 p1: Vec&lt;f64&gt;, // 错误概率数组 p0_denom: f64, p1_denom: f64, pabusive: f64, // 错误率 vocabs: Vec&lt;String&gt;,&#125;pub struct Bayes &#123; init_val: f64, // 所有词的初始化出现数 denom: f64, // 默认分母 p0: Array1&lt;f64&gt;, // 正确概率数组 p1: Array1&lt;f64&gt;, // 错误概率数组 p0_denom: f64, p1_denom: f64, pabusive: f64, // 错误率 vocabs: HashSet&lt;String&gt;, jieba: Jieba,&#125;impl Bayes &#123; /// 创建朴素贝叶斯实例 /// # 参数 /// ## init_val: f64 /// 向量的默认值，如果小于0.0，将被设置为1.0 /// ## denom: f64 /// 默认分母，如果小于等于0.0，将被设置为2.0 /// /// # 返回值：Bayes /// 返回素朴贝叶斯实例 pub fn new(init_val: f64, denom: f64) -&gt; Bayes &#123; let mut init_val = init_val; let mut denom = denom; if init_val &lt; 0.0 &#123; init_val = 1.0; &#125; if denom &lt;= 0.0 &#123; denom = 2.0; &#125; Bayes &#123; init_val, denom, p0: arr1(&amp;[]), p1: arr1(&amp;[]), p0_denom: 0.0, p1_denom: 0.0, pabusive: 0.0, vocabs: HashSet::new(), jieba: Jieba::new(), &#125; &#125; /// 训练模型 /// # 参数 /// ## data_set: &amp;str /// 该参数为文件路径，带训练的数据集，该数据集需要进行预处理将其中的空格全部去除，然后使用空格将标签与内容进行分隔,如下所示： /// /// &gt; 0 这是一条正常短信 /// &gt; 1 这是一条垃圾短信 /// /// # 返回值：Result /// 成功时返回空元组，失败时返回错误提示信息 pub fn train(&amp;mut self, data_set: &amp;str) -&gt; Result&lt;(), &amp;'static str&gt; &#123; let mut classifys: Vec&lt;f64&gt; = Vec::new(); // 分类 let mut texts: Vec&lt;Vec&lt;String&gt;&gt; = Vec::new(); // 加载数据 if let Ok(lines) = utils::read_lines(data_set) &#123; for line in lines &#123; if let Ok(v) = line &#123; let vs: Vec&lt;&amp;str&gt; = v.split(' ').collect(); // 获取分类 if let Some(c) = vs.get(0) &#123; if let Ok(c1) = c.parse() &#123; classifys.push(c1); &#125; else &#123; return Err(\"classify format failed\"); &#125; &#125; else &#123; return Err(\"get classify failed\"); &#125; // 获取内容 if let Some(t) = vs.get(1) &#123; let t1: Vec&lt;String&gt; = self .jieba .cut(t, false) .into_iter() .map(String::from) .collect(); texts.push(t1); &#125; else &#123; return Err(\"get text failed\"); &#125; &#125; &#125; &#125; else &#123; return Err(\"read data_set failed\"); &#125; // -- 加载数据 // 获取唯一词汇 for doc in &amp;texts &#123; // let doc: HashSet&lt;&amp;String&gt; = doc.iter().collect(); self.vocabs = self .vocabs .union(&amp;doc.iter().map(String::from).collect()) .into_iter() .map(|x| x.to_string()) .collect(); &#125; // println!(\"&#123;:?&#125;\", self.vocabs); // 将文本数据转为对应存在的数字向量 // 根据数据内容初始化2D数组 let mut vocab_of_arr = Array2::from_elem((texts.len(), self.vocabs.len()), 0.0); for (line, doc) in (&amp;texts).iter().enumerate() &#123; for w in doc &#123; if let Some(col) = self.vocabs.iter().position(|x| x == w) &#123; vocab_of_arr.row_mut(line)[col] = 1.0; &#125; &#125; &#125; // println!(\"&#123;:?&#125;\", vocab_of_arr); // 将分类数据存储array let classifys = match Array1::from_shape_vec((&amp;classifys).len(), classifys) &#123; Ok(vec) =&gt; vec, Err(_) =&gt; return Err(\"gen classifys array failed\"), &#125;; // println!(\"&#123;:?&#125;\", classifys); // 计算错误占比 self.pabusive = classifys.sum() as f64 / classifys.len() as f64; self.p0 = Array1::from_elem(self.vocabs.len(), self.init_val); self.p1 = Array1::from_elem(self.vocabs.len(), self.init_val); self.p0_denom = self.denom; self.p1_denom = self.denom; for (i, classify) in classifys.iter().enumerate() &#123; if *classify == 1.0 &#123; self.p1 += &amp;vocab_of_arr.row(i); self.p1_denom += &amp;vocab_of_arr.row(i).sum(); &#125; else &#123; self.p0 += &amp;vocab_of_arr.row(i); self.p0_denom += &amp;vocab_of_arr.row(i).sum(); &#125; &#125; let calc = |z: &amp;Array1&lt;f64&gt;, d: f64| -&gt; Array1&lt;f64&gt; &#123; z.iter().map(|x| (x / d).log(std::f64::consts::E)).collect() &#125;; self.p0 = calc(&amp;self.p0, self.p0_denom); self.p1 = calc(&amp;self.p1, self.p1_denom); Ok(()) &#125; /// 分类器 /// # 参数 /// ## text: &amp;str /// 待分类的文本字符串 /// /// # 返回值：Result /// 如果分类成功，则返回Ok变体。如果分类失败，则返回Err变体。 /// Ok变体中如果p1 &gt; p0则为true，否则为false。 pub fn classify(&amp;self, text: &amp;str) -&gt; Result&lt;bool, &amp;'static str&gt; &#123; if text == \"\" &#123; return Err(\"text ie empty\"); &#125; let text_vec = self.jieba.cut(text, false); let mut train_vec = Array1::from_elem(self.vocabs.len(), 0.0); for w in &amp;text_vec &#123; if let Some(col) = self.vocabs.iter().position(|x| x == *w) &#123; train_vec[col] = 1.0; &#125; &#125; let p0: f64 = (&amp;train_vec * &amp;self.p0).sum() + (1.0 - self.pabusive.log(std::f64::consts::E)); let p1: f64 = (&amp;train_vec * &amp;self.p1).sum() + (self.pabusive.log(std::f64::consts::E)); Ok(p1 &gt; p0) &#125; /// 保存训练模型 pub fn save_model(&amp;self, model_name: &amp;str) -&gt; Result&lt;(), &amp;'static str&gt; &#123; // 转换数据类型 let vocabs: Vec&lt;String&gt; = self.vocabs.iter().map(|x| x.to_string()).collect(); let p0: Vec&lt;f64&gt; = self.p0.to_vec(); let p1: Vec&lt;f64&gt; = self.p1.to_vec(); // json对象 let model = BayesModel &#123; init_val: self.init_val, denom: self.denom, p0, p1, p0_denom: self.p0_denom, p1_denom: self.p1_denom, pabusive: self.pabusive, vocabs, &#125;; let json_str = match serde_json::to_string(&amp;model) &#123; Ok(v) =&gt; v, Err(_) =&gt; return Err(\"model to json string failed\"), &#125;; let mut file = match fs::File::create(model_name) &#123; Ok(f) =&gt; f, Err(_) =&gt; return Err(\"create model file failed\"), &#125;; file.write_all(json_str.as_bytes()) .map_err(|_| \"write model failed\")?; Ok(()) &#125; /// 加载模型 pub fn load_model(&amp;mut self, model_path: &amp;str) -&gt; Result&lt;(), &amp;'static str&gt; &#123; let model_str = match fs::read_to_string(model_path) &#123; Ok(v) =&gt; v, Err(_) =&gt; return Err(\"read model failed\"), &#125;; let model: BayesModel = match serde_json::from_str(&amp;model_str) &#123; Ok(v) =&gt; v, Err(_) =&gt; return Err(\"json to model failed\"), &#125;; self.p0 = match Array1::from_shape_vec(model.p0.len(), model.p0) &#123; Ok(v) =&gt; v, Err(_) =&gt; return Err(\"set p0 failed\"), &#125;; self.p1 = match Array1::from_shape_vec(model.p1.len(), model.p1) &#123; Ok(v) =&gt; v, Err(_) =&gt; return Err(\"set p1 failed\"), &#125;; self.vocabs = model.vocabs.iter().map(|x| x.to_string()).collect(); self.pabusive = model.pabusive; Ok(()) &#125;&#125;#[cfg(test)]mod tests &#123; use super::*; #[test] fn test_train_and_save() &#123; let mut b = Bayes::new(1.0, 2.0); b.train(\"sms_data.txt\").unwrap(); b.save_model(\"bayes_model.json\").unwrap(); &#125; #[test] fn test_load_and_classify() &#123; let mut b = Bayes::new(1.0, 2.0); b.load_model(\"bayes_model.json\").unwrap(); println!(\"star\"); println!(\"&#123;&#125;\", b.classify(\"验证码417520，用于注册/登录，10分钟内有效。验证码提供给他人可能导致账号被盗，请勿泄漏，谨防被骗。 \").unwrap()); println!(\"end\"); &#125;&#125;","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://guaik.github.io/tags/rust/"},{"name":"机器学习","slug":"机器学习","permalink":"https://guaik.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://guaik.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"CentOS7部署MongoDB副本集","slug":"CentOS7部署MongoDB副本集","date":"2020-08-09T06:39:39.000Z","updated":"2020-09-24T06:14:47.238Z","comments":true,"path":"2020/08/09/CentOS7部署MongoDB副本集/","link":"","permalink":"https://guaik.github.io/2020/08/09/CentOS7%E9%83%A8%E7%BD%B2MongoDB%E5%89%AF%E6%9C%AC%E9%9B%86/","excerpt":"","text":"安装MongoDB创建mongodb源文件vi /etc/yum.repos.d/mongodb-org-4.4.repo 输入以下内容123456[mongodb-org-4.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc 使用yum安装sudo yum install -y mongodb-org 配置副本集创建以下目录 目录名 用途 config 存储配置文件 data 存储数据文件 keyfile 存储密钥文件 log 存储日志文件 run 存储pid文件 123456mkdir ~/mongodbcd ~/mongodbmkdir config data keyfile log runcd datamkdir node1 node2 node3cd .. 编辑节点1配置文件vi ./config/node1.conf 输入以下内容 123456789101112131415161718192021222324252627282930net: port: 26001 bindIp: 0.0.0.0storage: engine: wiredTiger directoryPerDB: true dbPath: ~/mongodb/data/node1 journal: enabled: truesystemLog: destination: file logAppend: true path: ~/mongodb/log/node1.logoperationProfiling: slowOpThresholdMs: 10000replication: oplogSizeMB: 10240 replSetName: guaikprocessManagement: fork: true pidFilePath: ~/mongodb/run/node1.pidsecurity: authorization: \"enabled\" clusterAuthMode: keyFile keyFile: ~/mongodb/keyfile/mongo.key 字段名 描述 port 监听端口号 replSetName 是节点名称 复制该配置文件，创建节点2和节点3的配置文件 12cp ./config/node1.conf ./config/node2.confcp ./config/node1.conf ./config/node3.conf node2.conf和node3.conf分别使用端口：26002和26003，并且修改数据目录，日志目录和pid文件（将相关的node1改成node2和node3即可）。 创建密钥文件12openssl rand -base64 756 &gt; ./keyfile/mongo.keychmod 600 ./keyfile/mongo.key 启动节点和关闭节点123456789# 启动节点mongod -f ~/mongodb/config/node1.conf --authmongod -f ~/mongodb/config/node2.conf --authmongod -f ~/mongodb/config/node3.conf --auth# 关闭节点mongod -f ～/mongodb/config.node1.cinf --shutdownmongod -f ～/mongodb/config.node2.cinf --shutdownmongod -f ～/mongodb/config.node3.cinf --shutdown 连接节点并初始化副本集mongo --port=26001 连接成功后输入输入以下指令，创建副本集配置。 12345678config = &#123; _id : \"guaik\", members : [ &#123;_id : 0, host : \"192.168.1.100:26001\" &#125;, &#123;_id : 1, host : \"192.168.1.101:26002\" &#125;, &#123;_id : 2, host : \"192.168.1.102:26003\"&#125; ]&#125;; 初始化副本集 rs.initiate(config); 查看创建状态 rs.status() 配置admin用户123456use admin;db.createUser(&#123; user:\"admin\", pwd:\"admin\", roles:[&#123;role:\"root\",db:\"admin\"&#125;]&#125;); 切换admin数据库并登陆12use admin;db.auth(\"admin\", \"admin\"); 客户端连接副本集字符串1mongodb://admin:admin@&#123;host&#125;:26001,&#123;host&#125;:26002,&#123;host&#125;:26003 连接失败的请检查防火墙是否开放端口。","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://guaik.github.io/tags/mongodb/"}]},{"title":"搞定网络爬虫登陆验证-使用浏览器Cookie","slug":"搞定网络爬虫登陆验证-使用浏览器Cookie","date":"2020-06-04T02:04:40.000Z","updated":"2020-06-04T08:46:32.439Z","comments":true,"path":"2020/06/04/搞定网络爬虫登陆验证-使用浏览器Cookie/","link":"","permalink":"https://guaik.github.io/2020/06/04/%E6%90%9E%E5%AE%9A%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81-%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8Cookie/","excerpt":"","text":"登陆验证是什么？https://www.wjx.cn/wjx/viewfile.aspx?path=https%3a%2f%2fpubuserqiniu.paperol.cn%2f80373144_1_q1_1591205817ZF4mBh.png%3fattname%3d1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png&amp;activity=80373144 先点上边链接，发现打开的不是一张图片，而是一个登陆页面。 登陆 分析url分析上边url是一个图片连接，但是实际的图片url是作为参数(path)传给服务器的 1https%3a%2f%2fpubuserqiniu.paperol.cn%2f80373144_1_q1_1591205817ZF4mBh.png%3fattname%3d1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png 使用url解码看下图片地址 1https://pubuserqiniu.paperol.cn/80373144_1_q1_1591205817ZF4mBh.png?attname=1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png 可以知道图片存储用的是七牛云的对象存储服务。 登陆分析 Chrome浏览器，打开“开发者工具”，点击“Network”，如果“Network”中存在内容，就先清空一下。 输入账号密码（可能需要输入验证码）登陆，查看“Network”中的数据： 当输入完账号密码后，图片已经被下载了 分析 通过上图可以知道获取一个图片是经过了3个步骤的，前两步骤的返回状态码都是302（重定向），第三步才是真正的请求。 点击第一个URL 分析1 因为是302状态，所以检查返回数据的头部信息，能够发现两个关键参数：1、重定向地址（Location）。2、本地请求会在本地设置的Cookie。 所有我们在开发脚本的时候也会使用到Cookie的功能。 点击第二个URL(为第一个URL重定向的目标地址) 分析2 这里有个重要信息，重定向的地址中带有token参数 第三步，最后一步！ 分析3 继续分析返回数据，发现Content-Type是image/png，这时候就可以确认返回的数据是图片格式了。 爬虫设计开发语言：Python3.X 需求1：需要登陆验证，并且要处理登陆验证码实现：直接使用浏览器登陆后使用浏览器生成的Cookie，用到的库： 1pip3 install browser_cookie3 需求2：在请求数据的时候，前两次重定向应答的headers中都需要设置Cookie实现：使用urllib.request.HTTPCookieProcessor来管理Cookie DEMO⚠️注意事项： 1、测试发现需要登陆管理后台，下载最新的分析报告(excel)，从里边拿到图片的url才能使用当前浏览器的Cookie进行操作。 2、第一次GET请求后发现headers中没有Location字段，但是在返回内容中找到了重定向用到的的url，所以用xpath提取出来使用。 3、browser_cookie3获取Chrome的Cookie存在问题，获取Firefox的Cookie可正常使用。 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import browser_cookie3import urllib.requestfrom lxml import etreedef download(): url = \"https://www.wjx.cn/wjx/viewfile.aspx?path=https%3a%2f%2fpubuserqiniu.paperol.cn%2f80373144_1_q1_1591205817ZF4mBh.png%3fattname%3d1_1_3EADD86A-FFEB-469C-A77E-A6F5C7B0D635.png&amp;activity=80373144\" filename = \"./demo.png\" try: # 加载火狐浏览器Cookie cj = browser_cookie3.Firefox().load() opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj)) request = urllib.request.Request(url) # 第一次请求 response = opener.open(request) data = response.read() html = etree.HTML(data) url = 'https://www.wjx.cn' + html.xpath('//a/@href')[0] request = urllib.request.Request(url, method=\"GET\") # 第二次请求 response = opener.open(request) if (response.getcode() == 200): with open(filename, \"wb\") as f: f.write(response.read()) # 将内容写入图片 except Exception as e: print(e)if __name__ == \"__main__\": download() 备注请合理使用爬虫，遵循网站robot.txt规则","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://guaik.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"验证","slug":"验证","permalink":"https://guaik.github.io/tags/%E9%AA%8C%E8%AF%81/"}]},{"title":"Flutter使用SharedPreferences：单例+同步","slug":"Flutter使用SharedPreferences：单例+同步","date":"2020-05-23T13:38:32.000Z","updated":"2020-06-19T07:48:52.506Z","comments":true,"path":"2020/05/23/Flutter使用SharedPreferences：单例+同步/","link":"","permalink":"https://guaik.github.io/2020/05/23/Flutter%E4%BD%BF%E7%94%A8SharedPreferences%EF%BC%9A%E5%8D%95%E4%BE%8B+%E5%90%8C%E6%AD%A5/","excerpt":"","text":"Flutter如何本地存储K/V数据呢？SharedPreferences是个不错的选择，当然几乎所有嵌入式系统都支持SQLite，你乐意就好。 安装SharedPreferences 在pubspec.yaml中添加依赖项 12dependencies: shared_preferences: ^0.5.7+3 安装依赖项flutter pub get SharedPreferences如何使用？太简单了，直接上代码123456789101112// 存储token字符串void SetToken(token) async &#123; this.prefs = await SharedPreferences.getInstance(); this.prefs.setString(\"token\", token);&#125;// 获取token字符串Future&lt;String&gt; GetToken() async &#123; this.prefs = await SharedPreferences.getInstance(); String token = this.prefs.getString(\"token\"); return token == null ? \"\" : token;&#125; 上面示例用了setString和getString来处理字符串，还支持对int,bool,double,List&lt;String&gt;类型的处理。 示例分析 await SharedPreferences.getInstance()从这行代码可以了解到的信息是：1、SharedPreferences采用了异步调用。2、静态方法getInstance()可以确定它是个单例模式。 如果所有使用到存储的函数都采用异步调用可能会产生一些问题，在Flutter的页面代码中Widget build(BuildContext context)需要返回一个Widget的对象，有时候我们需要从本地存储中读取状态值来确定返回什么页面。如果是异步调用的话可能会返回一个null值而导致编译报错，因为异步调用不会等待函数执行完就继续执行下面的流程了，这时候很有可能就执行完函数并且什么都没返回。 123456789101112131415161718class _StartupPageState extends State&lt;StartupPage&gt; &#123; @override Widget build(BuildContext context) &#123; Widget page; SharedPreferences.getInstance().then((prefs) &#123; var isFirst = prefs.getBool(\"isFirst\"); if (isFirst == null || false) &#123; // 如果是第一次登陆，则显示启动页 page = BootstrapPage(); &#125; else &#123; // 否则执行跳转到登陆页 page = LoginPage(); &#125; &#125;); // 这里可能返回null值 return page; &#125;&#125; SharedPreferences使用单例模式再封装 在main函数中调用Init生成实力并存储SharedPreferences对，这样就不用每次异步获取了。 123456789101112131415class Storage &#123; Storage._(); SharedPreferences prefs; static Storage _instance; static Storage getInstance() &#123; if(_instance == null) &#123; _instance = Storage._(); &#125; return _instance; &#125; Init() async &#123; this.prefs = await SharedPreferences.getInstance(); &#125;&#125; 初始化123456789void startup() async &#123; await Storage.getInstance().Init(); runApp(new MyApp());&#125;void main() &#123; WidgetsFlutterBinding.ensureInitialized(); startup();&#125; 使用Storage单例 感谢猫哥提醒：在SharedPreferences中，所有的写入操作都是异步函数，包含（set, clear），所有的get都是同步函数。 1234567891011121314151617// 存储token字符串// setString为异步函数，如果是同步逻辑需要使用await。void SetToken(token) async&#123; await Storage.getInstance().prefs.setString(\"token\", token);&#125;// 获取token字符串String GetToken() &#123; String token = Storage.getInstance().prefs.getString(\"token\"); return token == null ? \"\" : token;&#125;// 获取是否第一次运行bool isFirst() &#123; var state = Storage.getInstance().prefs.getBool(\"isFirst\"); return state == null ? false : true;&#125;","categories":[{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/tags/flutter/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://guaik.github.io/tags/SharedPreferences/"},{"name":"单例模式","slug":"单例模式","permalink":"https://guaik.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"同步","slug":"同步","permalink":"https://guaik.github.io/tags/%E5%90%8C%E6%AD%A5/"}]},{"title":"递归算法，lua的table与json互转","slug":"递归算法，lua的table与json互转","date":"2020-04-15T04:10:00.000Z","updated":"2020-05-23T13:43:21.418Z","comments":true,"path":"2020/04/15/递归算法，lua的table与json互转/","link":"","permalink":"https://guaik.github.io/2020/04/15/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%8Clua%E7%9A%84table%E4%B8%8Ejson%E4%BA%92%E8%BD%AC/","excerpt":"","text":"标题几乎是关键词组成，那么这篇文章会讲些什么？ 递归算法的使用 golang调用lua的方法 lua中table与json的相互转换 递归算法特性处理层级关系的结构，遍历数据非它莫属 如何设计递归 层级分类，统一函数参数与返回值 何时开始返回 应用小白能听懂的：什么是层级关系的结构呢？在windows系统中有个“我的电脑”，“我的电脑”中还有C,D,E,F盘，C盘中还有windows目录存放系统文件，D盘中还有我珍藏多年的【日本***空小姐】。所以最简单的理解就是一层套一层的关系。 中白能听懂的：二叉树遍历，父子节点关系。json中一层层的花括号{}。这些都是明显的层级关系。 所以本文中处理table与json的转换就使用递归算法。 golang如何调用lua的方法lua是什么首先它是一门脚本语言，但是它特别适合嵌入其他的语言中。那么为什么要嵌入其他语言呢？自己都是一个语言了在嵌入个lua不多余吗？ 我就拿C++举个栗子，C++的程序每次更新代码都是需要重新编译链接的，哪怕改动一点逻辑就要重新编译才行。某些情况下程序经常会修改一些业务逻辑，游戏中的智能状态机，在调试的时候每次修改都需要重新编译链接就太麻烦了，如果把状态机写个接口给lua去调用，修改脚本就可以调整状态机的逻辑，这太爽了。 安装lua的依赖包 1go get github.com/yuin/gopher-lua lua的运行时环境lua的运行状态（State）存放着运行时的一些关键数据：运行堆栈，上下文数据等（记不清了讲多了你也记不住），总之不同的状态是相互独立的，不同的状态间数据是不可见的，所以多线程安全。 创建lua状态 1env := lua.NewState() golang与lua的交互lua作为一门嵌入式的语言，有个很重要的特点就是能够在lua中能够调用被寄生语言的函数（寄生兽看过吧？），这样就完成了被寄宿的语言开放接口，然后通过lua编写脚本就能够方便的修改逻辑了。 在lua中注册新的函数 1234567/// 转换的逻辑是由golang编写的提供给lua调用的接口代码/// lua本身不支持table与json互转// table转json字符串env.SetGlobal(\"jsonMarshal\", env.NewFunction(luaJson.JsonMarshal))// json字符串转tableenv.SetGlobal(\"jsonUnMarshal\", env.NewFunction(luaJson.JsonUnMarshal)) 相关接口代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package jsonimport ( \"encoding/json\" \"github.com/golang/glog\" lua \"github.com/yuin/gopher-lua\")// 检查Table是否为Listfunc checkList(value lua.LValue) (b bool) &#123; if value.Type().String() == \"table\" &#123; b = true value.(*lua.LTable).ForEach(func(k, v lua.LValue) &#123; if k.Type().String() != \"number\" &#123; b = false return &#125; &#125;) &#125; return&#125;func marshal(data lua.LValue) interface&#123;&#125; &#123; switch data.Type() &#123; case lua.LTTable: if checkList(data) &#123; jdata := make([]interface&#123;&#125;, 0) data.(*lua.LTable).ForEach(func(key, value lua.LValue) &#123; jdata = append(jdata, marshal(value)) &#125;) return jdata &#125; else &#123; jdata := map[string]interface&#123;&#125;&#123;&#125; data.(*lua.LTable).ForEach(func(key, value lua.LValue) &#123; jdata[key.String()] = marshal(value) &#125;) return jdata &#125; case lua.LTNumber: return float64(data.(lua.LNumber)) case lua.LTString: return string(data.(lua.LString)) case lua.LTBool: return bool(data.(lua.LBool)) &#125; return nil&#125;func JsonMarshal(L *lua.LState) int &#123; data := L.ToTable(1) str, err := json.Marshal(marshal(data)) if err != nil &#123; glog.Error(err) &#125; L.Push(lua.LString(str)) return 1&#125;func unmarshal(L *lua.LState, data interface&#123;&#125;) lua.LValue &#123; switch data.(type) &#123; case map[string]interface&#123;&#125;: tb := L.NewTable() for k, v := range data.(map[string]interface&#123;&#125;) &#123; tb.RawSet(lua.LString(k), unmarshal(L, v)) &#125; return tb case []interface&#123;&#125;: tb := L.NewTable() for i, v := range data.([]interface&#123;&#125;) &#123; tb.Insert(i+1, unmarshal(L, v)) &#125; return tb case float64: return lua.LNumber(data.(float64)) case string: return lua.LString(data.(string)) case bool: return lua.LBool(data.(bool)) &#125; return lua.LNil&#125;func JsonUnMarshal(L *lua.LState) int &#123; str := L.ToString(1) jdata := map[string]interface&#123;&#125;&#123;&#125; err := json.Unmarshal([]byte(str), &amp;jdata) if err != nil &#123; glog.Error(err) &#125; L.Push(unmarshal(L, jdata)) return 1&#125; 在lua中调用golang提供的接口1234567891011121314function processor() data = &#123;&#125; data[\"hello\"]=\"world\" data[\"a\"] = &#123;&#125; data[\"a\"][\"b\"] = \"b\" data[\"a\"][\"c\"] = &#123;1,2,3,4,5,6&#125; res = jsonMarshal(data) res = jsonUnMarshal(res) for k,v in ipairs(res[\"a\"][\"c\"]) do print(k,v) end return trueend","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"递归","slug":"递归","permalink":"https://guaik.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"lua","slug":"lua","permalink":"https://guaik.github.io/tags/lua/"},{"name":"table","slug":"table","permalink":"https://guaik.github.io/tags/table/"},{"name":"json","slug":"json","permalink":"https://guaik.github.io/tags/json/"}]},{"title":"消息队列在前端的应用","slug":"消息队列在前端的应用","date":"2020-04-12T16:21:12.000Z","updated":"2020-04-15T04:52:05.609Z","comments":true,"path":"2020/04/13/消息队列在前端的应用/","link":"","permalink":"https://guaik.github.io/2020/04/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"队列与堆栈的区别队列由一个入口和一个出口组成，先进先出。堆栈只有一个口，后进先出。 生产消费者模型与队列队列是可以用来做缓冲区使用的，当短时间内出现大量数据的时候会造成软件或整个系统的不稳定，这时候我们就可以把数据先丢到队列中缓存起来，然后以合适的速度获取并处理数据保障系统的稳定。这就是生产消费模型，生产者负责生产数据而消费者负责处理数据。 消息队列在后端开发的应用 电商平台有一项业务：秒杀活动。在极短的时间内服务器将会收到大量商品的购买请求，如何降低业务服务器受到的冲击呢？我们会使用消息队列进行削峰处理。常用的后端消息队列有：Kafka、RabbitMQ、ActiveMQ、ZeroMQ。 消息队列通常都支持多个订阅者，利用这个特性可以实现一些服务的负载均衡功能。 📝正题：队列在前端的应用限速，让界面更流畅一些在聊天室应用中少则0人多则上万人，在收到大量即时通讯消息时如果不加处理全部拿去在界面做渲染那么轻则界面卡顿重则APP卡死。微信小程序给出的调用setData的最佳时间间隔为20ms，也就是如果把数据刷新的频率控制在20ms刷新一次是更合理的。所以消费者应该每隔20ms获取并处理一条数据保障界面的不卡。 减少没必要的内存浪费这样降低了消费的速度，会导致队列中的数据积压严重，大量消耗内存资源，一条消息在几分钟后被看到也是可能的，那如何处理呢？假设1秒钟收到了1000条聊天消息，那么这些消息需要全部显示吗？至少我的眼睛是来不及看完的，所以可以设定队列的最大长度，超出的消息全部丢弃（长度根据实际场景设定）。 保障重要的消息快速显示并且必须显示有个用户在直播间刷了个火箭，嗯，火箭被外星人劫走不见了，世界未解之谜出现。或者由于数据的积压火箭1分钟后终于出现了，主播都下播了。 为了避免上述问题，我们需要VIP队列，如果说普通聊天消息放入普通队列，那么现金礼物的就要放入VIP队列插队了，并且使命必达，有一条显示一条。这个实现也很容易，VIP队列的最大长度为∞大，不判断长度就行了，虽然也达不到1秒1000个火箭的量，但鱼丸就说不定了。由于VIP队列是独立于普通队列的，所以消息不会被排在普通队列的末尾，实现了插队的功能，通常这个队列的量不会特别大所以能够快速显示出来。 数据的融合，屏幕能显示N个列表项就刷新N条数据如果一个屏幕只能显示10个列表项，你每次有必要刷新10000条数据吗？还不够卡吗？所以当屏幕只能显示10个列表项的时候每次只刷新最新的100条数据，更多的请看聊天记录。这样就又多了一个列表用来存储可见数据了，这个列表只干一件事，融合普通队列和VIP队列的消息用于setData时刷新到屏幕上的数据。 🚀实战项目：gqueuehttps://github.com/GUAIK-ORG/gqueue","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://guaik.github.io/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://guaik.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://guaik.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"队列","slug":"队列","permalink":"https://guaik.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"加权随机算法","slug":"加权随机算法","date":"2020-04-12T14:02:06.000Z","updated":"2020-04-12T14:26:38.217Z","comments":true,"path":"2020/04/12/加权随机算法/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/","excerpt":"","text":"白话原理生活中最常见的一个例子：现在有4个红球和6个黑球，把这10个球放入到一个不透明的袋子中打乱，那么去袋子中拿到红球的概率是4/10，拿到黑球的概率是6/10，也可以说袋子分配给我红球的概率是4/10，分配给我黑球的概率是6/10。 实际应用 网关服务器通常都会通过负载均衡去分摊计算压力，有的服务器性能会好一些，有的会差一些，所以我们可以通过权重配比的形式将较大的计算压力给到性能较好的服务器。 当某台服务器突然出现故障时，微服务架构可以通过服务注册发现将故障的服务器移除，如果是网关服务器的话我们可以将负载均衡的权重置0。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 实例对象type Object struct &#123; Weight int // 权重 Object interface&#123;&#125; // 服务对象&#125;// 调度对象type Dispatch struct &#123; Sources []*Object // 所有服务对象 SLB []*Object // 负载均衡生成的对象 TotalWeight int // 总权重&#125;// 初始化func (dispatch *Dispatch) Init() (err error) &#123; dispatch.Sources = make([]*LiveObject, 0) dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 return&#125;// 重新生成负载均衡队列func (dispatch *Dispatch) reGenSLBArray() &#123; dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 for _, item := range dispatch.Sources &#123; dispatch.TotalWeight += item.Weight for i := 0; i &lt; item.Weight; i++ &#123; dispatch.SLB = append(dispatch.SLB, item) &#125; &#125; // 随机排列顺序 rand.Seed(time.Now().UnixNano()) rand.Shuffle(dispatch.TotalWeight, func(i, j int) &#123; dispatch.SLB[i], dispatch.SLB[j] = dispatch.SLB[j], dispatch.SLB[i] &#125;)&#125;// 添加服务对象func (dispatch *Dispatch) AddObject(object *Object) &#123; dispatch.Sources = append(dispatch.Sources, object) dispatch.reGenSLBArray()&#125;// 获取对象func (dispatch *Dispatch) GetObject() (object *Object) &#123; rand.Seed(time.Now().UnixNano()) return dispatch.SLB[rand.Intn(dispatch.TotalWeight)]&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"基于Redis的分布式锁","slug":"基于Redis的分布式锁","date":"2020-04-12T12:38:39.000Z","updated":"2020-04-12T15:07:03.488Z","comments":true,"path":"2020/04/12/基于Redis的分布式锁/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"为什么要使用分布式锁举个栗子，在设计直播间开播流程的时候会执行很多初始化的操作，也会在缓存中创建本次直播的记录数据，为了避免主播误操作同时执行开播流程多次，在开播成功后会设置开播状态，开播时判断状态为已开播则不处理，直播系统是多实例部署的，为了保护开播状态，需要做到同一时间只能由一台服务器处理开播流程，这时候就会用到分布式锁进行加锁保护。 线程锁与分布式锁锁的意义在于保护全局可见对象。在单进程中使用多线程时会通过线程锁去保护当前进程中的全局对象（某些情况可用原子操作）。分布式系统可理解为多进程系统，线程锁无法锁住其他进程中的执行流程，所以需要一个全局的锁来管控所有进程中的执行流程（如果相同名称的锁处于上锁状态则等待）。 Redis与SetNXRedis是单进程系统，它的SetNX是个原子操作，我们可以利用这两点来实现分布式锁。如果SetNX执行成功则意味着拿到了锁，相反执行失败则循环等待拿锁或超时退出。 设计注意事项1、为了避免单持有锁的进程奔溃而无法释放锁，所以必须能够为锁设定过期时间自动释放锁资源。 2、使用TTL检查锁是否成功的被设置过期时间，如果返回-1（未被设置）的话，使用Expire为其设定过期时间。 3、在释放锁的时候需要使用Watch命令，确保监测的值在事务执行时时未被改变，如果其他进程修改了锁，会触发事务异常，然后重新执行Watch。 分享一个我写的Redis封装类，仅实现了连接和锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package daoimport ( \"time\" \"github.com/go-redis/redis/v7\" uuid \"github.com/satori/go.uuid\")type Rds struct &#123; Client *redis.Client AcquireTimeout int32 LockTimeout int32&#125;func NewRds(host, passwd string, db int) (rds *Rds, err error) &#123; rdsOpt := &amp;redis.Options&#123; Addr: host, Password: passwd, DB: db, &#125; client := redis.NewClient(rdsOpt) _, err = client.Ping().Result() if err != nil &#123; return &#125; rds = &amp;Rds&#123;Client: client, AcquireTimeout: 10, LockTimeout: 10&#125; return&#125;func (r *Rds) AcquireLockWithTimeout(key string) (identifier string, b bool) &#123; identifier = uuid.NewV4().String() lockname := \"lock:\" + key end := time.Now().Add(time.Second * time.Duration(r.AcquireTimeout)) for time.Now().Before(end) &#123; if r.Client.SetNX(lockname, identifier, time.Second*time.Duration(r.LockTimeout)).Val() &#123; // 如果key不存在，并成功设置了key b = true return &#125; else if r.Client.TTL(lockname).Val() == -1 &#123; // 如果key存在，但是没有剩余时间 r.Client.Expire(lockname, time.Second*time.Duration(r.LockTimeout)) &#125; time.Sleep(time.Microsecond) &#125; return&#125;func (r *Rds) ReleaseLock(key, identifier string) (b bool) &#123; lockname := \"lock:\" + key txf := func(tx *redis.Tx) error &#123; v, err := tx.Get(lockname).Result() if err != nil &#123; return err &#125; _, err = tx.Pipelined(func(pipe redis.Pipeliner) error &#123; if v == identifier &#123; pipe.Del(lockname) b = true &#125; return nil &#125;) return err &#125; for &#123; err := r.Client.Watch(txf, lockname) if err == nil &#123; break &#125; else if err == redis.TxFailedErr &#123; glog.Error(err) &#125; &#125; return&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}],"categories":[{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/categories/flutter/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://guaik.github.io/tags/rust/"},{"name":"机器学习","slug":"机器学习","permalink":"https://guaik.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://guaik.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"name":"mongodb","slug":"mongodb","permalink":"https://guaik.github.io/tags/mongodb/"},{"name":"爬虫","slug":"爬虫","permalink":"https://guaik.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"验证","slug":"验证","permalink":"https://guaik.github.io/tags/%E9%AA%8C%E8%AF%81/"},{"name":"flutter","slug":"flutter","permalink":"https://guaik.github.io/tags/flutter/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://guaik.github.io/tags/SharedPreferences/"},{"name":"单例模式","slug":"单例模式","permalink":"https://guaik.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"同步","slug":"同步","permalink":"https://guaik.github.io/tags/%E5%90%8C%E6%AD%A5/"},{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"递归","slug":"递归","permalink":"https://guaik.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"lua","slug":"lua","permalink":"https://guaik.github.io/tags/lua/"},{"name":"table","slug":"table","permalink":"https://guaik.github.io/tags/table/"},{"name":"json","slug":"json","permalink":"https://guaik.github.io/tags/json/"},{"name":"typescript","slug":"typescript","permalink":"https://guaik.github.io/tags/typescript/"},{"name":"javascript","slug":"javascript","permalink":"https://guaik.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://guaik.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"队列","slug":"队列","permalink":"https://guaik.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}