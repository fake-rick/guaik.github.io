{"meta":{"title":"怪客的Blog","subtitle":"分享一些黑科技","description":"","author":"guaik","url":"https://guaik.github.io","root":"/"},"pages":[{"title":"","date":"2020-04-12T11:13:05.159Z","updated":"2020-04-12T11:13:05.148Z","comments":false,"path":"categories/index.html","permalink":"https://guaik.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-12T11:12:33.068Z","updated":"2020-04-12T11:12:33.055Z","comments":false,"path":"tags/index.html","permalink":"https://guaik.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"加权随机算法","slug":"加权随机算法","date":"2020-04-12T14:02:06.000Z","updated":"2020-04-12T14:26:38.217Z","comments":true,"path":"2020/04/12/加权随机算法/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/","excerpt":"","text":"白话原理生活中最常见的一个例子：现在有4个红球和6个黑球，把这10个球放入到一个不透明的袋子中打乱，那么去袋子中拿到红球的概率是4/10，拿到黑球的概率是6/10，也可以说袋子分配给我红球的概率是4/10，分配给我黑球的概率是6/10。 实际应用 网关服务器通常都会通过负载均衡去分摊计算压力，有的服务器性能会好一些，有的会差一些，所以我们可以通过权重配比的形式将较大的计算压力给到性能较好的服务器。 当某台服务器突然出现故障时，微服务架构可以通过服务注册发现将故障的服务器移除，如果是网关服务器的话我们可以将负载均衡的权重置0。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 实例对象type Object struct &#123; Weight int // 权重 Object interface&#123;&#125; // 服务对象&#125;// 调度对象type Dispatch struct &#123; Sources []*Object // 所有服务对象 SLB []*Object // 负载均衡生成的对象 TotalWeight int // 总权重&#125;// 初始化func (dispatch *Dispatch) Init() (err error) &#123; dispatch.Sources = make([]*LiveObject, 0) dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 return&#125;// 重新生成负载均衡队列func (dispatch *Dispatch) reGenSLBArray() &#123; dispatch.SLB = make([]*LiveObject, 0) dispatch.TotalWeight = 0 for _, item := range dispatch.Sources &#123; dispatch.TotalWeight += item.Weight for i := 0; i &lt; item.Weight; i++ &#123; dispatch.SLB = append(dispatch.SLB, item) &#125; &#125; // 随机排列顺序 rand.Seed(time.Now().UnixNano()) rand.Shuffle(dispatch.TotalWeight, func(i, j int) &#123; dispatch.SLB[i], dispatch.SLB[j] = dispatch.SLB[j], dispatch.SLB[i] &#125;)&#125;// 添加服务对象func (dispatch *Dispatch) AddObject(object *Object) &#123; dispatch.Sources = append(dispatch.Sources, object) dispatch.reGenSLBArray()&#125;// 获取对象func (dispatch *Dispatch) GetObject() (object *Object) &#123; rand.Seed(time.Now().UnixNano()) return dispatch.SLB[rand.Intn(dispatch.TotalWeight)]&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"基于Redis的分布式锁","slug":"基于Redis的分布式锁","date":"2020-04-12T12:38:39.000Z","updated":"2020-04-12T14:06:26.652Z","comments":true,"path":"2020/04/12/基于Redis的分布式锁/","link":"","permalink":"https://guaik.github.io/2020/04/12/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"分布式锁1、为了避免单持有锁的进程奔溃而无法释放锁，所以必须能够为锁设定过期时间自动释放锁资源 2、使用TTL检查锁是否成功的被设置过期时间，如果返回-1（未被设置）的话，使用Expire为其设定过期时间 3、在释放锁的时候需要使用Watch命令，确保监测的值在事务执行时时未被改变，如果其他进程修改了锁，会触发事务异常，然后重新执行Watch。 分享一个我写的Redis封装类，仅实现了连接和锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package daoimport ( \"time\" \"github.com/go-redis/redis/v7\" uuid \"github.com/satori/go.uuid\")type Rds struct &#123; Client *redis.Client AcquireTimeout int32 LockTimeout int32&#125;func NewRds(host, passwd string, db int) (rds *Rds, err error) &#123; rdsOpt := &amp;redis.Options&#123; Addr: host, Password: passwd, DB: db, &#125; client := redis.NewClient(rdsOpt) _, err = client.Ping().Result() if err != nil &#123; return &#125; rds = &amp;Rds&#123;Client: client, AcquireTimeout: 10, LockTimeout: 10&#125; return&#125;func (r *Rds) AcquireLockWithTimeout(key string) (identifier string, b bool) &#123; identifier = uuid.NewV4().String() lockname := \"lock:\" + key end := time.Now().Add(time.Second * time.Duration(r.AcquireTimeout)) for time.Now().Before(end) &#123; if r.Client.SetNX(lockname, identifier, time.Second*time.Duration(r.LockTimeout)).Val() &#123; // 如果key不存在，并成功设置了key b = true return &#125; else if r.Client.TTL(lockname).Val() == -1 &#123; // 如果key存在，但是没有剩余时间 r.Client.Expire(lockname, time.Second*time.Duration(r.LockTimeout)) &#125; time.Sleep(time.Microsecond) &#125; return&#125;func (r *Rds) ReleaseLock(key, identifier string) (b bool) &#123; lockname := \"lock:\" + key txf := func(tx *redis.Tx) error &#123; v, err := tx.Get(lockname).Result() if err != nil &#123; return err &#125; _, err = tx.Pipelined(func(pipe redis.Pipeliner) error &#123; if v == identifier &#123; pipe.Del(lockname) b = true &#125; return nil &#125;) return err &#125; for &#123; err := r.Client.Watch(txf, lockname) if err == nil &#123; break &#125; else if err == redis.TxFailedErr &#123; glog.Error(err) &#125; &#125; return&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}],"categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://guaik.github.io/tags/golang/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guaik.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"redis","slug":"redis","permalink":"https://guaik.github.io/tags/redis/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://guaik.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]}